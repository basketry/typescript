/**
 * This code was generated by @basketry/express@{{version}}
 *
 * Changes to this file may cause incorrect behavior and will be lost if
 * the code is regenerated.
 *
 * To make changes to the contents of this file:
 * 1. Edit source/path.ext
 * 2. Run the Basketry CLI
 *
 * About Basketry: https://basketry.io
 * About @basketry/express: https://basketry.io/docs/components/@basketry/express
 */

import type { Request, Response } from 'express';
import { ZodError } from 'zod';

import type * as types from '../types';
import * as schemas from '../schemas';
import * as mappers from '../dtos/mappers';

import * as errors from './errors';
import type * as expressTypes from './types';

/** GET /authPermutations */
export const handleAllAuthSchemes =
  (
    getService: (req: Request, res: Response) => types.AuthPermutationService,
  ): expressTypes.AllAuthSchemesRequestHandler =>
  async (req, res, next) => {
    try {
      // Execute service method
      const service = getService(req, res);
      await service.allAuthSchemes();
      const status = 200;

      // Respond
      res.sendStatus(status);
    } catch (err) {
      if (err instanceof ZodError) {
        const statusCode = res.headersSent ? 500 : 400;
        return next(errors.validationErrors(statusCode, err.errors));
      } else {
        next(errors.unhandledException(err));
      }
    }
  };

/** PUT /authPermutations */
export const handleComboAuthSchemes =
  (
    getService: (req: Request, res: Response) => types.AuthPermutationService,
  ): expressTypes.ComboAuthSchemesRequestHandler =>
  async (req, res, next) => {
    try {
      // Execute service method
      const service = getService(req, res);
      await service.comboAuthSchemes();
      const status = 200;

      // Respond
      res.sendStatus(status);
    } catch (err) {
      if (err instanceof ZodError) {
        const statusCode = res.headersSent ? 500 : 400;
        return next(errors.validationErrors(statusCode, err.errors));
      } else {
        next(errors.unhandledException(err));
      }
    }
  };

/** POST /gizmos */
export const handleCreateGizmo =
  (
    getService: (req: Request, res: Response) => types.GizmoService,
  ): expressTypes.CreateGizmoRequestHandler =>
  async (req, res, next) => {
    try {
      // Parse parameters from request
      const params: types.CreateGizmoParams | undefined =
        schemas.CreateGizmoParamsSchema.optional().parse({
          size: req.query.size,
        });

      // Execute service method
      const service = getService(req, res);
      const result = await service.createGizmo(params);
      const status = 201;

      // Respond
      const responseDto = mappers.mapToGizmoDto(result);
      res.status(status).json(responseDto);

      // Validate response
      schemas.GizmoSchema.parse(result);
    } catch (err) {
      if (err instanceof ZodError) {
        const statusCode = res.headersSent ? 500 : 400;
        return next(errors.validationErrors(statusCode, err.errors));
      } else {
        next(errors.unhandledException(err));
      }
    }
  };

/** POST /widgets */
export const handleCreateWidget =
  (
    getService: (req: Request, res: Response) => types.WidgetService,
  ): expressTypes.CreateWidgetRequestHandler =>
  async (req, res, next) => {
    try {
      // Parse parameters from request
      const params: types.CreateWidgetParams | undefined =
        schemas.CreateWidgetParamsSchema.optional().parse({
          body: mappers.mapFromCreateWidgetBodyDto(req.body),
        });

      // Execute service method
      const service = getService(req, res);
      await service.createWidget(params);
      const status = 204;

      // Respond
      res.sendStatus(status);
    } catch (err) {
      if (err instanceof ZodError) {
        const statusCode = res.headersSent ? 500 : 400;
        return next(errors.validationErrors(statusCode, err.errors));
      } else {
        next(errors.unhandledException(err));
      }
    }
  };

/** DELETE /widgets/:id/foo */
export const handleDeleteWidgetFoo =
  (
    getService: (req: Request, res: Response) => types.WidgetService,
  ): expressTypes.DeleteWidgetFooRequestHandler =>
  async (req, res, next) => {
    try {
      // Parse parameters from request
      const params: types.DeleteWidgetFooParams =
        schemas.DeleteWidgetFooParamsSchema.parse({
          id: req.params.id,
        });

      // Execute service method
      const service = getService(req, res);
      await service.deleteWidgetFoo(params);
      const status = 204;

      // Respond
      res.sendStatus(status);
    } catch (err) {
      if (err instanceof ZodError) {
        const statusCode = res.headersSent ? 500 : 400;
        return next(errors.validationErrors(statusCode, err.errors));
      } else {
        next(errors.unhandledException(err));
      }
    }
  };

/** GET /exhaustive */
export const handleExhaustiveFormats =
  (
    getService: (req: Request, res: Response) => types.ExhaustiveService,
  ): expressTypes.ExhaustiveFormatsRequestHandler =>
  async (req, res, next) => {
    try {
      // Parse parameters from request
      const params: types.ExhaustiveFormatsParams | undefined =
        schemas.ExhaustiveFormatsParamsSchema.optional().parse({
          stringNoFormat: req.query['string-no-format'],
          stringDate: req.query['string-date'],
          stringDateTime: req.query['string-date-time'],
          integerNoFormat: req.query['integer-no-format'],
          integerInt32: req.query['integer-int32'],
          integerInt64: req.query['integer-int64'],
          numberNoFormat: req.query['number-no-format'],
          numberFloat: req.query['number-float'],
          numberDouble: req.query['number-double'],
        });

      // Execute service method
      const service = getService(req, res);
      await service.exhaustiveFormats(params);
      const status = 204;

      // Respond
      res.sendStatus(status);
    } catch (err) {
      if (err instanceof ZodError) {
        const statusCode = res.headersSent ? 500 : 400;
        return next(errors.validationErrors(statusCode, err.errors));
      } else {
        next(errors.unhandledException(err));
      }
    }
  };

/** GET /exhaustive/{path-string}/{path-enum}/{path-number}/{path-integer}/{path-boolean}/{path-string-array}/{path-enum-array}/{path-number-array}/{path-integer-array}/{path-boolean-array} */
export const handleExhaustiveParams =
  (
    getService: (req: Request, res: Response) => types.ExhaustiveService,
  ): expressTypes.ExhaustiveParamsRequestHandler =>
  async (req, res, next) => {
    try {
      // Parse parameters from request
      const params: types.ExhaustiveParamsParams =
        schemas.ExhaustiveParamsParamsSchema.parse({
          queryString: req.query['query-string'],
          queryEnum: req.query['query-enum'],
          queryNumber: req.query['query-number'],
          queryInteger: req.query['query-integer'],
          queryBoolean: req.query['query-boolean'],
          queryStringArray: req.query['query-string-array']?.split(','),
          queryEnumArray: req.query['query-enum-array']?.split(','),
          queryNumberArray: req.query['query-number-array']?.split(','),
          queryIntegerArray: req.query['query-integer-array']?.split(','),
          queryBooleanArray: req.query['query-boolean-array']?.split(','),
          pathString: req.params['path-string'],
          pathEnum: req.params['path-enum'],
          pathNumber: req.params['path-number'],
          pathInteger: req.params['path-integer'],
          pathBoolean: req.params['path-boolean'],
          pathStringArray: req.params['path-string-array']?.split(','),
          pathEnumArray: req.params['path-enum-array']?.split('|'),
          pathNumberArray: req.params['path-number-array']?.split(' '),
          pathIntegerArray: req.params['path-integer-array']?.split('\t'),
          pathBooleanArray: req.params['path-boolean-array']?.split(','),
          headerString: req.header['header-string'],
          headerEnum: req.header['header-enum'],
          headerNumber: req.header['header-number'],
          headerInteger: req.header['header-integer'],
          headerBoolean: req.header['header-boolean'],
          headerStringArray: req.header['header-string-array']?.split(','),
          headerEnumArray: req.header['header-enum-array']?.split(','),
          headerNumberArray: req.header['header-number-array']?.split('|'),
          headerIntegerArray: req.header['header-integer-array']?.split(' '),
          headerBooleanArray: req.header['header-boolean-array']?.split('\t'),
          body: mappers.mapFromExhaustiveParamsBodyDto(req.body),
        });

      // Execute service method
      const service = getService(req, res);
      await service.exhaustiveParams(params);
      const status = 204;

      // Respond
      res.sendStatus(status);
    } catch (err) {
      if (err instanceof ZodError) {
        const statusCode = res.headersSent ? 500 : 400;
        return next(errors.validationErrors(statusCode, err.errors));
      } else {
        next(errors.unhandledException(err));
      }
    }
  };

/** GET /gizmos @deprecated */
export const handleGetGizmos =
  (
    getService: (req: Request, res: Response) => types.GizmoService,
  ): expressTypes.GetGizmosRequestHandler =>
  async (req, res, next) => {
    try {
      // Parse parameters from request
      const params: types.GetGizmosParams | undefined =
        schemas.GetGizmosParamsSchema.optional().parse({
          search: req.query.search,
        });

      // Execute service method
      const service = getService(req, res);
      const result = await service.getGizmos(params);
      const status = 200;

      // Respond
      const responseDto = mappers.mapToGizmosResponseDto(result);
      res.status(status).json(responseDto);

      // Validate response
      schemas.GizmosResponseSchema.parse(result);
    } catch (err) {
      if (err instanceof ZodError) {
        const statusCode = res.headersSent ? 500 : 400;
        return next(errors.validationErrors(statusCode, err.errors));
      } else {
        next(errors.unhandledException(err));
      }
    }
  };

/** GET /widgets/:id/foo */
export const handleGetWidgetFoo =
  (
    getService: (req: Request, res: Response) => types.WidgetService,
  ): expressTypes.GetWidgetFooRequestHandler =>
  async (req, res, next) => {
    try {
      // Parse parameters from request
      const params: types.GetWidgetFooParams =
        schemas.GetWidgetFooParamsSchema.parse({
          id: req.params.id,
        });

      // Execute service method
      const service = getService(req, res);
      const result = await service.getWidgetFoo(params);
      const status = 200;

      // Respond
      const responseDto = mappers.mapToWidgetDto(result);
      res.status(status).json(responseDto);

      // Validate response
      schemas.WidgetSchema.parse(result);
    } catch (err) {
      if (err instanceof ZodError) {
        const statusCode = res.headersSent ? 500 : 400;
        return next(errors.validationErrors(statusCode, err.errors));
      } else {
        next(errors.unhandledException(err));
      }
    }
  };

/** GET /widgets */
export const handleGetWidgets =
  (
    getService: (req: Request, res: Response) => types.WidgetService,
  ): expressTypes.GetWidgetsRequestHandler =>
  async (req, res, next) => {
    try {
      // Execute service method
      const service = getService(req, res);
      const result = await service.getWidgets();
      const status = 200;

      // Respond
      const responseDto = mappers.mapToWidgetDto(result);
      res.status(status).json(responseDto);

      // Validate response
      schemas.WidgetSchema.parse(result);
    } catch (err) {
      if (err instanceof ZodError) {
        const statusCode = res.headersSent ? 500 : 400;
        return next(errors.validationErrors(statusCode, err.errors));
      } else {
        next(errors.unhandledException(err));
      }
    }
  };

/** PUT /widgets */
export const handlePutWidget =
  (
    getService: (req: Request, res: Response) => types.WidgetService,
  ): expressTypes.PutWidgetRequestHandler =>
  async (req, res, next) => {
    try {
      // Execute service method
      const service = getService(req, res);
      await service.putWidget();
      const status = 200;

      // Respond
      res.sendStatus(status);
    } catch (err) {
      if (err instanceof ZodError) {
        const statusCode = res.headersSent ? 500 : 400;
        return next(errors.validationErrors(statusCode, err.errors));
      } else {
        next(errors.unhandledException(err));
      }
    }
  };

/** GET /mapDemo */
export const handleReturnMaps =
  (
    getService: (req: Request, res: Response) => types.MapDemoService,
  ): expressTypes.ReturnMapsRequestHandler =>
  async (req, res, next) => {
    try {
      // Execute service method
      const service = getService(req, res);
      const result = await service.returnMaps();
      const status = 200;

      // Respond
      const responseDto = mappers.mapToAllMapsDto(result);
      res.status(status).json(responseDto);

      // Validate response
      schemas.AllMapsSchema.parse(result);
    } catch (err) {
      if (err instanceof ZodError) {
        const statusCode = res.headersSent ? 500 : 400;
        return next(errors.validationErrors(statusCode, err.errors));
      } else {
        next(errors.unhandledException(err));
      }
    }
  };

/** POST /mapDemo */
export const handleSendMaps =
  (
    getService: (req: Request, res: Response) => types.MapDemoService,
  ): expressTypes.SendMapsRequestHandler =>
  async (req, res, next) => {
    try {
      // Parse parameters from request
      const params: types.SendMapsParams | undefined =
        schemas.SendMapsParamsSchema.optional().parse({
          allMaps: mappers.mapFromAllMapsDto(req.body),
        });

      // Execute service method
      const service = getService(req, res);
      await service.sendMaps(params);
      const status = 200;

      // Respond
      res.sendStatus(status);
    } catch (err) {
      if (err instanceof ZodError) {
        const statusCode = res.headersSent ? 500 : 400;
        return next(errors.validationErrors(statusCode, err.errors));
      } else {
        next(errors.unhandledException(err));
      }
    }
  };

/** PUT /gizmos */
export const handleUpdateGizmo =
  (
    getService: (req: Request, res: Response) => types.GizmoService,
  ): expressTypes.UpdateGizmoRequestHandler =>
  async (req, res, next) => {
    try {
      // Parse parameters from request
      const params: types.UpdateGizmoParams | undefined =
        schemas.UpdateGizmoParamsSchema.optional().parse({
          factors: req.query.factors?.split(','),
        });

      // Execute service method
      const service = getService(req, res);
      const result = await service.updateGizmo(params);
      const status = 200;

      // Respond
      const responseDto = mappers.mapToGizmoDto(result);
      res.status(status).json(responseDto);

      // Validate response
      schemas.GizmoSchema.parse(result);
    } catch (err) {
      if (err instanceof ZodError) {
        const statusCode = res.headersSent ? 500 : 400;
        return next(errors.validationErrors(statusCode, err.errors));
      } else {
        next(errors.unhandledException(err));
      }
    }
  };
