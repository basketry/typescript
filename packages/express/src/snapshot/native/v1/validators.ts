/**
 * This code was generated by @basketry/typescript-validators@0.1.0
 *
 * Changes to this file may cause incorrect behavior and will be lost if
 * the code is regenerated.
 *
 * To make changes to the contents of this file:
 * 1. Edit source/path.ext
 * 2. Run the Basketry CLI
 *
 * About Basketry: https://basketry.io
 * About @basketry/typescript-validators: https://github.com/basketry/typescript-validators
 */

import * as types from './types';
import * as sanitizers from './sanitizers';

export type ValidationError = {
  code:
    | 'ARRAY_MAX_ITEMS'
    | 'ARRAY_MIN_ITEMS'
    | 'NUMBER_MULTIPLE_OF'
    | 'REQUIRED'
    | 'STRING_ENUM'
    | 'STRING_MAX_LENGTH'
    | 'STRING_PATTERN'
    | 'TYPE';
  title: string;
  path: string;
};

type ValidationFunction = (
  value: any,
  path: string,
  isRequired: boolean,
) => ValidationError[];

class Validator {
  constructor(private readonly parentPath?: string) {}
  private _errors: ValidationError[] = [];
  get errors(): ValidationError[] {
    return this._errors;
  }

  required(value: any, path: string) {
    return {
      ensure: (...validators: ValidationFunction[]) =>
        this.run(value, path, [required, ...validators], true),
    };
  }

  optional(value: any, path: string) {
    return {
      ensure: (...validators: ValidationFunction[]) =>
        this.run(value, path, validators, false),
    };
  }

  private run(
    value: any,
    path: string,
    validators: ValidationFunction[],
    isRequired: boolean,
  ) {
    if (typeof value === 'undefined' && !isRequired) return;
    for (const validator of validators) {
      this._errors.push(
        ...validator(
          value,
          this.parentPath ? `${this.parentPath}.${path}` : path,
          isRequired,
        ),
      );
    }
  }
}

const required: ValidationFunction = (value, path) => {
  if (typeof value === 'undefined') {
    return [{ code: 'REQUIRED', title: `"${path}" is required`, path }];
  }
  return [];
};

const array: (...validators: ValidationFunction[]) => ValidationFunction =
  (...validators) =>
  (value, path, isRequired) => {
    if (Array.isArray(value)) {
      const errors: ValidationError[] = [];

      for (const [index, item] of value.entries()) {
        for (const validator of validators) {
          errors.push(...validator(item, `${path}[${index}]`, isRequired));
        }
      }

      return errors;
    } else if (typeof value !== 'undefined') {
      return [
        {
          code: 'TYPE',
          title: `"${path}" must be an array${
            isRequired ? '' : ' if supplied'
          }`,
          path,
        },
      ];
    } else {
      return [];
    }
  };
const maxItems: (max: number) => ValidationFunction =
  (max) => (value, path, isRequired) => {
    if (Array.isArray(value) && value.length > max) {
      return [
        {
          code: 'ARRAY_MAX_ITEMS',
          title: `"${path}" must have at most ${max} items${
            isRequired ? '' : ' if supplied'
          }`,
          path,
        },
      ];
    }
    return [];
  };
const minItems: (min: number) => ValidationFunction =
  (min) => (value, path, isRequired) => {
    if (Array.isArray(value) && value.length < min) {
      return [
        {
          code: 'ARRAY_MIN_ITEMS',
          title: `"${path}" must have at least ${min} items${
            isRequired ? '' : ' if supplied'
          }`,
          path,
        },
      ];
    }
    return [];
  };
const using: (
  validator: (value: any, parentPath?: string) => ValidationError[],
) => ValidationFunction = (validator) => (value, path) =>
  validator(value, path);

function nativeType(
  value: any,
  path: string,
  primitive: 'string' | 'number' | 'boolean',
  isRequired: boolean,
): ValidationError[] {
  if (
    typeof value !== primitive &&
    (isRequired || typeof value !== 'undefined')
  ) {
    return [
      {
        code: 'TYPE',
        title: `"${path}" must be a ${primitive}${
          isRequired ? ' if supplied' : ''
        }`,
        path,
      },
    ];
  }
  return [];
}

const string: ValidationFunction = (value, path, isRequred) => {
  return nativeType(value, path, 'string', isRequred);
};

const number: ValidationFunction = (value, path, isRequred) => {
  return nativeType(value, path, 'number', isRequred);
};
const integer: ValidationFunction = (value, path, isRequired) => {
  if (
    (typeof value === 'number' && value % 1 !== 0) ||
    (typeof value !== 'number' && (isRequired || typeof value !== 'undefined'))
  ) {
    return [
      {
        code: 'TYPE',
        title: `"${path}" must be an integer${
          isRequired ? ' if supplied' : ''
        }`,
        path,
      },
    ];
  }
  return [];
};

const boolean: ValidationFunction = (value, path, isRequred) => {
  return nativeType(value, path, 'boolean', isRequred);
};

const date: ValidationFunction = (value, path, isRequired) => {
  if (value instanceof Date) return [];
  if (isRequired || typeof value !== 'undefined') {
    return [
      {
        code: 'TYPE',
        title: `"${path}" must be a Date${isRequired ? ' if supplied' : ''}`,
        path,
      },
    ];
  }
  return [];
};

const maxLength: (max: number) => ValidationFunction =
  (max) => (value, path, isRequired) => {
    if (typeof value === 'string' && value.length > max) {
      return [
        {
          code: 'STRING_MAX_LENGTH',
          title: `"${path}" must be at most ${max} characters${
            isRequired ? '' : ' if supplied'
          }`,
          path,
        },
      ];
    }
    return [];
  };

const pattern: (regex: RegExp) => ValidationFunction =
  (regex) => (value, path, isRequired) => {
    if (typeof value === 'string' && !regex.test(value)) {
      return [
        {
          code: 'STRING_PATTERN',
          title: `"${path}" must match the pattern "${regex}"${
            isRequired ? '' : ' if supplied'
          }`,
          path,
        },
      ];
    }
    return [];
  };
const multipleOf: (factor: number) => ValidationFunction =
  (factor) => (value, path, isRequired) => {
    if (isRequired || typeof value !== 'undefined') {
      if (typeof value === 'number' && value % factor !== 0) {
        return [
          {
            code: 'NUMBER_MULTIPLE_OF',
            title: `"${path}" must be a multiple of ${factor}${
              isRequired ? '' : ' if supplied'
            }`,
            path,
          },
        ];
      }
    }
    return [];
  };

/**
 * Validates input parameters for the allAuthSchemes() method.
 */
export function validateAllAuthSchemesParams(
  parentPath?: string,
): ValidationError[] {
  const validator = new Validator(parentPath);

  return validator.errors;
}

/**
 * Validates input parameters for the comboAuthSchemes() method.
 */
export function validateComboAuthSchemesParams(
  parentPath?: string,
): ValidationError[] {
  const validator = new Validator(parentPath);

  return validator.errors;
}

/**
 * Validates input parameters for the createGizmo() method.
 */
export function validateCreateGizmoParams(
  params?: types.CreateGizmoParams,
  parentPath?: string,
): ValidationError[] {
  if (!params) return [];
  const validator = new Validator(parentPath);

  validator
    .optional(params.size, 'size')
    .ensure(using(validateCreateGizmoSize));

  return validator.errors;
}

/**
 * Validates input parameters for the createWidget() method.
 */
export function validateCreateWidgetParams(
  params?: types.CreateWidgetParams,
  parentPath?: string,
): ValidationError[] {
  if (!params) return [];
  const validator = new Validator(parentPath);

  validator
    .optional(params.body, 'body')
    .ensure(using(validateCreateWidgetBody));

  return validator.errors;
}

/**
 * Validates input parameters for the deleteWidgetFoo() method.
 */
export function validateDeleteWidgetFooParams(
  params: types.DeleteWidgetFooParams,
  parentPath?: string,
): ValidationError[] {
  const validator = new Validator(parentPath);

  validator.required(params.id, 'id').ensure(string, maxLength(30));

  return validator.errors;
}

/**
 * Validates input parameters for the exhaustiveFormats() method.
 */
export function validateExhaustiveFormatsParams(
  params?: types.ExhaustiveFormatsParams,
  parentPath?: string,
): ValidationError[] {
  if (!params) return [];
  const validator = new Validator(parentPath);

  validator.optional(params.integerInt32, 'integer-int32').ensure(integer);
  validator.optional(params.integerInt64, 'integer-int64').ensure(integer);
  validator
    .optional(params.integerNoFormat, 'integer-no-format')
    .ensure(integer);
  validator.optional(params.numberDouble, 'number-double').ensure(number);
  validator.optional(params.numberFloat, 'number-float').ensure(number);
  validator.optional(params.numberNoFormat, 'number-no-format').ensure(number);
  validator.optional(params.stringDate, 'string-date').ensure(date);
  validator.optional(params.stringDateTime, 'string-date-time').ensure(date);
  validator.optional(params.stringNoFormat, 'string-no-format').ensure(string);

  return validator.errors;
}

/**
 * Validates input parameters for the exhaustiveParams() method.
 */
export function validateExhaustiveParamsParams(
  params: types.ExhaustiveParamsParams,
  parentPath?: string,
): ValidationError[] {
  const validator = new Validator(parentPath);

  validator
    .optional(params.body, 'body')
    .ensure(using(validateExhaustiveParamsBody));
  validator.optional(params.headerBoolean, 'header-boolean').ensure(boolean);
  validator
    .optional(params.headerBooleanArray, 'header-boolean-array')
    .ensure(array(boolean));
  validator
    .optional(params.headerEnum, 'header-enum')
    .ensure(using(validateExhaustiveParamsHeaderEnum));
  validator
    .optional(params.headerEnumArray, 'header-enum-array')
    .ensure(array(using(validateExhaustiveParamsHeaderEnumArray)));
  validator.optional(params.headerInteger, 'header-integer').ensure(integer);
  validator
    .optional(params.headerIntegerArray, 'header-integer-array')
    .ensure(array(integer));
  validator.optional(params.headerNumber, 'header-number').ensure(number);
  validator
    .optional(params.headerNumberArray, 'header-number-array')
    .ensure(array(number));
  validator.optional(params.headerString, 'header-string').ensure(string);
  validator
    .optional(params.headerStringArray, 'header-string-array')
    .ensure(array(string));
  validator.required(params.pathBoolean, 'path-boolean').ensure(boolean);
  validator
    .required(params.pathBooleanArray, 'path-boolean-array')
    .ensure(array(boolean));
  validator
    .required(params.pathEnum, 'path-enum')
    .ensure(using(validateExhaustiveParamsPathEnum));
  validator
    .required(params.pathEnumArray, 'path-enum-array')
    .ensure(array(using(validateExhaustiveParamsPathEnumArray)));
  validator.required(params.pathInteger, 'path-integer').ensure(integer);
  validator
    .required(params.pathIntegerArray, 'path-integer-array')
    .ensure(array(integer));
  validator.required(params.pathNumber, 'path-number').ensure(number);
  validator
    .required(params.pathNumberArray, 'path-number-array')
    .ensure(array(number));
  validator.required(params.pathString, 'path-string').ensure(string);
  validator
    .required(params.pathStringArray, 'path-string-array')
    .ensure(array(string));
  validator.optional(params.queryBoolean, 'query-boolean').ensure(boolean);
  validator
    .optional(params.queryBooleanArray, 'query-boolean-array')
    .ensure(array(boolean));
  validator
    .optional(params.queryEnum, 'query-enum')
    .ensure(using(validateExhaustiveParamsQueryEnum));
  validator
    .optional(params.queryEnumArray, 'query-enum-array')
    .ensure(array(using(validateExhaustiveParamsQueryEnumArray)));
  validator.optional(params.queryInteger, 'query-integer').ensure(integer);
  validator
    .optional(params.queryIntegerArray, 'query-integer-array')
    .ensure(array(integer));
  validator.optional(params.queryNumber, 'query-number').ensure(number);
  validator
    .optional(params.queryNumberArray, 'query-number-array')
    .ensure(array(number));
  validator.optional(params.queryString, 'query-string').ensure(string);
  validator
    .optional(params.queryStringArray, 'query-string-array')
    .ensure(array(string));

  return validator.errors;
}

/**
 * Validates input parameters for the getGizmos() method.
 */
export function validateGetGizmosParams(
  params?: types.GetGizmosParams,
  parentPath?: string,
): ValidationError[] {
  if (!params) return [];
  const validator = new Validator(parentPath);

  validator.optional(params.search, 'search').ensure(string);

  return validator.errors;
}

/**
 * Validates input parameters for the getWidgetFoo() method.
 */
export function validateGetWidgetFooParams(
  params: types.GetWidgetFooParams,
  parentPath?: string,
): ValidationError[] {
  const validator = new Validator(parentPath);

  validator.required(params.id, 'id').ensure(string, maxLength(30));

  return validator.errors;
}

/**
 * Validates input parameters for the getWidgets() method.
 */
export function validateGetWidgetsParams(
  parentPath?: string,
): ValidationError[] {
  const validator = new Validator(parentPath);

  return validator.errors;
}

/**
 * Validates input parameters for the putWidget() method.
 */
export function validatePutWidgetParams(
  parentPath?: string,
): ValidationError[] {
  const validator = new Validator(parentPath);

  return validator.errors;
}

/**
 * Validates input parameters for the updateGizmo() method.
 */
export function validateUpdateGizmoParams(
  params?: types.UpdateGizmoParams,
  parentPath?: string,
): ValidationError[] {
  if (!params) return [];
  const validator = new Validator(parentPath);

  validator
    .optional(params.factors, 'factors')
    .ensure(maxItems(6), minItems(2), array(string, pattern(/[0-9a-fA-F]+/)));

  return validator.errors;
}

export function validateCreateWidgetBody(
  params: types.CreateWidgetBody,
  parentPath?: string,
): ValidationError[] {
  const validator = new Validator(parentPath);

  validator.required(params.name, 'name').ensure(string);

  return validator.errors;
}
export function isCreateWidgetBody(obj: any): obj is types.CreateWidgetBody {
  return typeof obj !== 'undefined' && !validateCreateWidgetBody(obj).length;
}

export function validateExhaustiveParamsBody(
  params: types.ExhaustiveParamsBody,
  parentPath?: string,
): ValidationError[] {
  const validator = new Validator(parentPath);

  validator.optional(params.bar, 'bar').ensure(string);
  validator.optional(params.foo, 'foo').ensure(string);

  return validator.errors;
}
export function isExhaustiveParamsBody(
  obj: any,
): obj is types.ExhaustiveParamsBody {
  return (
    typeof obj !== 'undefined' && !validateExhaustiveParamsBody(obj).length
  );
}

export function validateGizmo(
  params: types.Gizmo,
  parentPath?: string,
): ValidationError[] {
  const validator = new Validator(parentPath);

  validator.optional(params.id, 'id').ensure(string, maxLength(30));
  validator.optional(params.name, 'name').ensure(string);
  validator.optional(params.size, 'size').ensure(using(validateProductSize));

  return validator.errors;
}
export function isGizmo(obj: any): obj is types.Gizmo {
  return typeof obj !== 'undefined' && !validateGizmo(obj).length;
}

export function validateGizmosResponse(
  params: types.GizmosResponse,
  parentPath?: string,
): ValidationError[] {
  const validator = new Validator(parentPath);

  validator.required(params.data, 'data').ensure(array(using(validateGizmo)));

  return validator.errors;
}
export function isGizmosResponse(obj: any): obj is types.GizmosResponse {
  return typeof obj !== 'undefined' && !validateGizmosResponse(obj).length;
}

export function validateNewWidget(
  params: types.NewWidget,
  parentPath?: string,
): ValidationError[] {
  const validator = new Validator(parentPath);

  validator.optional(params.buzz, 'buzz').ensure(number, multipleOf(5));
  validator.required(params.fiz, 'fiz').ensure(number, multipleOf(3));
  validator.optional(params.fizbuzz, 'fizbuzz').ensure(number, multipleOf(15));
  validator.optional(params.foo, 'foo').ensure(using(validateNewWidgetFoo));
  validator
    .optional(params.name, 'name')
    .ensure(string, maxLength(30), pattern(/[0-9a-fA-F]+/));
  validator.optional(params.size, 'size').ensure(using(validateProductSize));

  return validator.errors;
}
export function isNewWidget(obj: any): obj is types.NewWidget {
  return typeof obj !== 'undefined' && !validateNewWidget(obj).length;
}

export function validateNewWidgetFoo(
  params: types.NewWidgetFoo,
  parentPath?: string,
): ValidationError[] {
  const validator = new Validator(parentPath);

  validator.required(params.buzz, 'buzz').ensure(number);
  validator.optional(params.fiz, 'fiz').ensure(number);

  return validator.errors;
}
export function isNewWidgetFoo(obj: any): obj is types.NewWidgetFoo {
  return typeof obj !== 'undefined' && !validateNewWidgetFoo(obj).length;
}

export function validateWidget(
  params: types.Widget,
  parentPath?: string,
): ValidationError[] {
  const validator = new Validator(parentPath);

  validator.optional(params.buzz, 'buzz').ensure(number, multipleOf(5));
  validator.required(params.fiz, 'fiz').ensure(number, multipleOf(3));
  validator.optional(params.fizbuzz, 'fizbuzz').ensure(number, multipleOf(15));
  validator.optional(params.foo, 'foo').ensure(using(validateWidgetFoo));
  validator.required(params.id, 'id').ensure(string, maxLength(30));
  validator
    .optional(params.name, 'name')
    .ensure(string, maxLength(30), pattern(/[0-9a-fA-F]+/));
  validator.optional(params.size, 'size').ensure(using(validateProductSize));

  return validator.errors;
}
export function isWidget(obj: any): obj is types.Widget {
  return typeof obj !== 'undefined' && !validateWidget(obj).length;
}

export function validateWidgetFoo(
  params: types.WidgetFoo,
  parentPath?: string,
): ValidationError[] {
  const validator = new Validator(parentPath);

  validator.required(params.buzz, 'buzz').ensure(number);
  validator.optional(params.fiz, 'fiz').ensure(number);

  return validator.errors;
}
export function isWidgetFoo(obj: any): obj is types.WidgetFoo {
  return typeof obj !== 'undefined' && !validateWidgetFoo(obj).length;
}

export function validateCreateGizmoSize(
  value: types.CreateGizmoSize,
): ValidationError[] {
  const errors: ValidationError[] = [];
  if (
    typeof value === 'string' &&
    !['small', 'medium', 'big', 'XL'].includes(value)
  ) {
    errors.push({
      code: 'STRING_ENUM',
      title: 'Value must be one of ["small", "medium", "big", "XL"]',
      path: '',
    });
  }
  return [];
}

export function validateExhaustiveParamsHeaderEnum(
  value: types.ExhaustiveParamsHeaderEnum,
): ValidationError[] {
  const errors: ValidationError[] = [];
  if (typeof value === 'string' && !['one', 'two', 'three'].includes(value)) {
    errors.push({
      code: 'STRING_ENUM',
      title: 'Value must be one of ["one", "two", "three"]',
      path: '',
    });
  }
  return [];
}

export function validateExhaustiveParamsHeaderEnumArray(
  value: types.ExhaustiveParamsHeaderEnumArray,
): ValidationError[] {
  const errors: ValidationError[] = [];
  if (typeof value === 'string' && !['one', 'two', 'three'].includes(value)) {
    errors.push({
      code: 'STRING_ENUM',
      title: 'Value must be one of ["one", "two", "three"]',
      path: '',
    });
  }
  return [];
}

export function validateExhaustiveParamsPathEnum(
  value: types.ExhaustiveParamsPathEnum,
): ValidationError[] {
  const errors: ValidationError[] = [];
  if (typeof value === 'string' && !['one', 'two', 'three'].includes(value)) {
    errors.push({
      code: 'STRING_ENUM',
      title: 'Value must be one of ["one", "two", "three"]',
      path: '',
    });
  }
  return [];
}

export function validateExhaustiveParamsPathEnumArray(
  value: types.ExhaustiveParamsPathEnumArray,
): ValidationError[] {
  const errors: ValidationError[] = [];
  if (typeof value === 'string' && !['one', 'two', 'three'].includes(value)) {
    errors.push({
      code: 'STRING_ENUM',
      title: 'Value must be one of ["one", "two", "three"]',
      path: '',
    });
  }
  return [];
}

export function validateExhaustiveParamsQueryEnum(
  value: types.ExhaustiveParamsQueryEnum,
): ValidationError[] {
  const errors: ValidationError[] = [];
  if (typeof value === 'string' && !['one', 'two', 'three'].includes(value)) {
    errors.push({
      code: 'STRING_ENUM',
      title: 'Value must be one of ["one", "two", "three"]',
      path: '',
    });
  }
  return [];
}

export function validateExhaustiveParamsQueryEnumArray(
  value: types.ExhaustiveParamsQueryEnumArray,
): ValidationError[] {
  const errors: ValidationError[] = [];
  if (typeof value === 'string' && !['one', 'two', 'three'].includes(value)) {
    errors.push({
      code: 'STRING_ENUM',
      title: 'Value must be one of ["one", "two", "three"]',
      path: '',
    });
  }
  return [];
}

export function validateProductSize(
  value: types.ProductSize,
): ValidationError[] {
  const errors: ValidationError[] = [];
  if (
    typeof value === 'string' &&
    !['small', 'medium', 'large'].includes(value)
  ) {
    errors.push({
      code: 'STRING_ENUM',
      title: 'Value must be one of ["small", "medium", "large"]',
      path: '',
    });
  }
  return [];
}

export function validateExampleUnion(
  params: types.ExampleUnion,
): ValidationError[] {
  const errors: ValidationError[] = [];

  const gizmoErrors = validateGizmo(params as types.Gizmo);
  if (!gizmoErrors.length) return [];
  errors.push(...gizmoErrors);

  const widgetErrors = validateWidget(params as types.Widget);
  if (!widgetErrors.length) return [];
  errors.push(...widgetErrors);

  return errors;
}

export type ResponseBuilder<T> = (
  validationErrors: ValidationError[],
  err: any,
) => T;
export class ValidatedAuthPermutationService
  implements types.AuthPermutationService
{
  constructor(
    private readonly service: types.AuthPermutationService,
    private readonly handlers: { buildVoid: ResponseBuilder<void> },
  ) {}

  async allAuthSchemes() {
    const validationErrors: ValidationError[] = [];
    try {
      return this.service.allAuthSchemes();
    } catch (err) {
      return this.handlers.buildVoid(validationErrors, err);
    }
  }

  async comboAuthSchemes() {
    const validationErrors: ValidationError[] = [];
    try {
      return this.service.comboAuthSchemes();
    } catch (err) {
      return this.handlers.buildVoid(validationErrors, err);
    }
  }
}

export class ValidatedExhaustiveService implements types.ExhaustiveService {
  constructor(
    private readonly service: types.ExhaustiveService,
    private readonly handlers: { buildVoid: ResponseBuilder<void> },
  ) {}

  async exhaustiveFormats(params?: types.ExhaustiveFormatsParams) {
    let validationErrors: ValidationError[] = [];
    try {
      validationErrors = validateExhaustiveFormatsParams(params);
      if (validationErrors.length) {
        return this.handlers.buildVoid(validationErrors, undefined);
      }
      const sanitizedParams =
        sanitizers.sanitizeExhaustiveFormatsParams(params);
      return this.service.exhaustiveFormats(sanitizedParams);
    } catch (err) {
      return this.handlers.buildVoid(validationErrors, err);
    }
  }

  async exhaustiveParams(params: types.ExhaustiveParamsParams) {
    let validationErrors: ValidationError[] = [];
    try {
      validationErrors = validateExhaustiveParamsParams(params);
      if (validationErrors.length) {
        return this.handlers.buildVoid(validationErrors, undefined);
      }
      const sanitizedParams = sanitizers.sanitizeExhaustiveParamsParams(params);
      return this.service.exhaustiveParams(sanitizedParams);
    } catch (err) {
      return this.handlers.buildVoid(validationErrors, err);
    }
  }
}

export class ValidatedGizmoService implements types.GizmoService {
  constructor(
    private readonly service: types.GizmoService,
    private readonly handlers: {
      buildGizmo: ResponseBuilder<types.Gizmo>;
      buildGizmosResponse: ResponseBuilder<types.GizmosResponse>;
    },
  ) {}

  async createGizmo(params?: types.CreateGizmoParams) {
    let validationErrors: ValidationError[] = [];
    try {
      validationErrors = validateCreateGizmoParams(params);
      if (validationErrors.length) {
        return sanitizers.sanitizeGizmo(
          this.handlers.buildGizmo(validationErrors, undefined),
        );
      }
      const sanitizedParams = sanitizers.sanitizeCreateGizmoParams(params);
      return sanitizers.sanitizeGizmo(
        await this.service.createGizmo(sanitizedParams),
      );
    } catch (err) {
      return sanitizers.sanitizeGizmo(
        this.handlers.buildGizmo(validationErrors, err),
      );
    }
  }

  async getGizmos(params?: types.GetGizmosParams) {
    let validationErrors: ValidationError[] = [];
    try {
      validationErrors = validateGetGizmosParams(params);
      if (validationErrors.length) {
        return sanitizers.sanitizeGizmosResponse(
          this.handlers.buildGizmosResponse(validationErrors, undefined),
        );
      }
      const sanitizedParams = sanitizers.sanitizeGetGizmosParams(params);
      return sanitizers.sanitizeGizmosResponse(
        await this.service.getGizmos(sanitizedParams),
      );
    } catch (err) {
      return sanitizers.sanitizeGizmosResponse(
        this.handlers.buildGizmosResponse(validationErrors, err),
      );
    }
  }

  async updateGizmo(params?: types.UpdateGizmoParams) {
    let validationErrors: ValidationError[] = [];
    try {
      validationErrors = validateUpdateGizmoParams(params);
      if (validationErrors.length) {
        return sanitizers.sanitizeGizmo(
          this.handlers.buildGizmo(validationErrors, undefined),
        );
      }
      const sanitizedParams = sanitizers.sanitizeUpdateGizmoParams(params);
      return sanitizers.sanitizeGizmo(
        await this.service.updateGizmo(sanitizedParams),
      );
    } catch (err) {
      return sanitizers.sanitizeGizmo(
        this.handlers.buildGizmo(validationErrors, err),
      );
    }
  }
}

export class ValidatedWidgetService implements types.WidgetService {
  constructor(
    private readonly service: types.WidgetService,
    private readonly handlers: {
      buildWidget: ResponseBuilder<types.Widget>;
      buildVoid: ResponseBuilder<void>;
    },
  ) {}

  async createWidget(params?: types.CreateWidgetParams) {
    let validationErrors: ValidationError[] = [];
    try {
      validationErrors = validateCreateWidgetParams(params);
      if (validationErrors.length) {
        return this.handlers.buildVoid(validationErrors, undefined);
      }
      const sanitizedParams = sanitizers.sanitizeCreateWidgetParams(params);
      return this.service.createWidget(sanitizedParams);
    } catch (err) {
      return this.handlers.buildVoid(validationErrors, err);
    }
  }

  async deleteWidgetFoo(params: types.DeleteWidgetFooParams) {
    let validationErrors: ValidationError[] = [];
    try {
      validationErrors = validateDeleteWidgetFooParams(params);
      if (validationErrors.length) {
        return this.handlers.buildVoid(validationErrors, undefined);
      }
      const sanitizedParams = sanitizers.sanitizeDeleteWidgetFooParams(params);
      return this.service.deleteWidgetFoo(sanitizedParams);
    } catch (err) {
      return this.handlers.buildVoid(validationErrors, err);
    }
  }

  async getWidgetFoo(params: types.GetWidgetFooParams) {
    let validationErrors: ValidationError[] = [];
    try {
      validationErrors = validateGetWidgetFooParams(params);
      if (validationErrors.length) {
        return sanitizers.sanitizeWidget(
          this.handlers.buildWidget(validationErrors, undefined),
        );
      }
      const sanitizedParams = sanitizers.sanitizeGetWidgetFooParams(params);
      return sanitizers.sanitizeWidget(
        await this.service.getWidgetFoo(sanitizedParams),
      );
    } catch (err) {
      return sanitizers.sanitizeWidget(
        this.handlers.buildWidget(validationErrors, err),
      );
    }
  }

  async getWidgets() {
    const validationErrors: ValidationError[] = [];
    try {
      return sanitizers.sanitizeWidget(await this.service.getWidgets());
    } catch (err) {
      return sanitizers.sanitizeWidget(
        this.handlers.buildWidget(validationErrors, err),
      );
    }
  }

  async putWidget() {
    const validationErrors: ValidationError[] = [];
    try {
      return this.service.putWidget();
    } catch (err) {
      return this.handlers.buildVoid(validationErrors, err);
    }
  }
}
