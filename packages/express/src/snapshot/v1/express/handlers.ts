/**
 * This code was generated by @basketry/express@{{version}}
 *
 * Changes to this file may cause incorrect behavior and will be lost if
 * the code is regenerated.
 *
 * To make changes to the contents of this file:
 * 1. Edit source/path.ext
 * 2. Run the Basketry CLI
 *
 * About Basketry: https://github.com/basketry/basketry/wiki
 * About @basketry/express: https://github.com/basketry/express/wiki
 */

import type { Request } from 'express';

import type * as types from '../types';
import * as validators from '../validators';

import * as errors from './errors';
import * as mappers from './mappers';
import type * as expressTypes from './types';

/** GET /authPermutations */
export const handleAllAuthSchemes =
  (
    getService: (req: Request) => types.AuthPermutationService,
  ): expressTypes.AllAuthSchemesRequestHandler =>
  async (req, res, next) => {
    try {
      // Excetute service method
      const service = getService(req);
      await service.allAuthSchemes();
      const status = 200;

      // Respond
      res.sendStatus(status);
    } catch (err) {
      next(errors.unhandledException(err));
    }
  };

/** PUT /authPermutations */
export const handleComboAuthSchemes =
  (
    getService: (req: Request) => types.AuthPermutationService,
  ): expressTypes.ComboAuthSchemesRequestHandler =>
  async (req, res, next) => {
    try {
      // Excetute service method
      const service = getService(req);
      await service.comboAuthSchemes();
      const status = 200;

      // Respond
      res.sendStatus(status);
    } catch (err) {
      next(errors.unhandledException(err));
    }
  };

/** POST /gizmos */
export const handleCreateGizmo =
  (
    getService: (req: Request) => types.GizmoService,
  ): expressTypes.CreateGizmoRequestHandler =>
  async (req, res, next) => {
    try {
      // Parse parameters from request
      const params: types.CreateGizmoParams = {
        size: req.query.size as types.CreateGizmoSize,
      };

      // Validate request
      const reqValidationErrors = validators.validateCreateGizmoParams(params);
      if (reqValidationErrors.length) {
        return next(errors.validationErrors(400, reqValidationErrors));
      }

      // Excetute service method
      const service = getService(req);
      const result = await service.createGizmo(params);
      const status = 201;

      // Respond
      const reponseDto = mappers.mapToGizmoDto(result);
      res.status(status).json(reponseDto);

      // Validate response
      const resValidationErrors = validators.validateGizmo(result);
      if (resValidationErrors.length) {
        next(errors.validationErrors(500, resValidationErrors));
      }
    } catch (err) {
      next(errors.unhandledException(err));
    }
  };

/** POST /widgets */
export const handleCreateWidget =
  (
    getService: (req: Request) => types.WidgetService,
  ): expressTypes.CreateWidgetRequestHandler =>
  async (req, res, next) => {
    try {
      // Parse parameters from request
      const params: types.CreateWidgetParams = {
        body: mappers.mapFromCreateWidgetBodyDto(req.body),
      };

      // Validate request
      const reqValidationErrors = validators.validateCreateWidgetParams(params);
      if (reqValidationErrors.length) {
        return next(errors.validationErrors(400, reqValidationErrors));
      }

      // Excetute service method
      const service = getService(req);
      await service.createWidget(params);
      const status = 204;

      // Respond
      res.sendStatus(status);
    } catch (err) {
      next(errors.unhandledException(err));
    }
  };

/** DELETE /widgets/:id/foo */
export const handleDeleteWidgetFoo =
  (
    getService: (req: Request) => types.WidgetService,
  ): expressTypes.DeleteWidgetFooRequestHandler =>
  async (req, res, next) => {
    try {
      // Parse parameters from request
      const params: types.DeleteWidgetFooParams = {
        id: req.params.id,
      };

      // Validate request
      const reqValidationErrors =
        validators.validateDeleteWidgetFooParams(params);
      if (reqValidationErrors.length) {
        return next(errors.validationErrors(400, reqValidationErrors));
      }

      // Excetute service method
      const service = getService(req);
      await service.deleteWidgetFoo(params);
      const status = 204;

      // Respond
      res.sendStatus(status);
    } catch (err) {
      next(errors.unhandledException(err));
    }
  };

/** GET /exhaustive */
export const handleExhaustiveFormats =
  (
    getService: (req: Request) => types.ExhaustiveService,
  ): expressTypes.ExhaustiveFormatsRequestHandler =>
  async (req, res, next) => {
    try {
      // Parse parameters from request
      const params: types.ExhaustiveFormatsParams = {
        integerInt32: coerceToNumber(req.query['integer-int32']),
        integerInt64: coerceToNumber(req.query['integer-int64']),
        integerNoFormat: coerceToNumber(req.query['integer-no-format']),
        numberDouble: coerceToNumber(req.query['number-double']),
        numberFloat: coerceToNumber(req.query['number-float']),
        numberNoFormat: coerceToNumber(req.query['number-no-format']),
        stringDate: coerceToDate(req.query['string-date']),
        stringDateTime: coerceToDate(req.query['string-date-time']),
        stringNoFormat: req.query['string-no-format'],
      };

      // Validate request
      const reqValidationErrors =
        validators.validateExhaustiveFormatsParams(params);
      if (reqValidationErrors.length) {
        return next(errors.validationErrors(400, reqValidationErrors));
      }

      // Excetute service method
      const service = getService(req);
      await service.exhaustiveFormats(params);
      const status = 204;

      // Respond
      res.sendStatus(status);
    } catch (err) {
      next(errors.unhandledException(err));
    }
  };

/** GET /exhaustive/{path-string}/{path-enum}/{path-number}/{path-integer}/{path-boolean}/{path-string-array}/{path-enum-array}/{path-number-array}/{path-integer-array}/{path-boolean-array} */
export const handleExhaustiveParams =
  (
    getService: (req: Request) => types.ExhaustiveService,
  ): expressTypes.ExhaustiveParamsRequestHandler =>
  async (req, res, next) => {
    try {
      // Parse parameters from request
      const params: types.ExhaustiveParamsParams = {
        body: mappers.mapFromExhaustiveParamsBodyDto(req.body),
        headerBoolean: coerceToBoolean(req.header['header-boolean']),
        headerBooleanArray: req.header['header-boolean-array']
          ?.split('\t')
          .map(coerceToBoolean)
          .filter(definedBooleans),
        headerEnum: req.header[
          'header-enum'
        ] as types.ExhaustiveParamsHeaderEnum,
        headerEnumArray: req.header['header-enum-array']?.split(
          ',',
        ) as types.ExhaustiveParamsHeaderEnumArray[],
        headerInteger: coerceToNumber(req.header['header-integer']),
        headerIntegerArray: req.header['header-integer-array']
          ?.split(' ')
          .map(coerceToNumber)
          .filter(definedNumbers),
        headerNumber: coerceToNumber(req.header['header-number']),
        headerNumberArray: req.header['header-number-array']
          ?.split('|')
          .map(coerceToNumber)
          .filter(definedNumbers),
        headerString: req.header['header-string'],
        headerStringArray: req.header['header-string-array']?.split(','),
        pathBoolean: coerceToBoolean(req.params['path-boolean']),
        pathBooleanArray: req.params['path-boolean-array']
          .split(',')
          .map(coerceToBoolean)
          .filter(definedBooleans),
        pathEnum: req.params['path-enum'] as types.ExhaustiveParamsPathEnum,
        pathEnumArray: req.params['path-enum-array'].split(
          '|',
        ) as types.ExhaustiveParamsPathEnumArray[],
        pathInteger: coerceToNumber(req.params['path-integer']),
        pathIntegerArray: req.params['path-integer-array']
          .split('\t')
          .map(coerceToNumber)
          .filter(definedNumbers),
        pathNumber: coerceToNumber(req.params['path-number']),
        pathNumberArray: req.params['path-number-array']
          .split(' ')
          .map(coerceToNumber)
          .filter(definedNumbers),
        pathString: req.params['path-string'],
        pathStringArray: req.params['path-string-array'].split(','),
        queryBoolean: coerceToBoolean(req.query['query-boolean']),
        queryBooleanArray: req.query['query-boolean-array']
          ?.split(',')
          .map(coerceToBoolean)
          .filter(definedBooleans),
        queryEnum: req.query['query-enum'] as types.ExhaustiveParamsQueryEnum,
        queryEnumArray: req.query['query-enum-array']?.split(
          ',',
        ) as types.ExhaustiveParamsQueryEnumArray[],
        queryInteger: coerceToNumber(req.query['query-integer']),
        queryIntegerArray: req.query['query-integer-array']
          ?.split(',')
          .map(coerceToNumber)
          .filter(definedNumbers),
        queryNumber: coerceToNumber(req.query['query-number']),
        queryNumberArray: req.query['query-number-array']
          ?.split(',')
          .map(coerceToNumber)
          .filter(definedNumbers),
        queryString: req.query['query-string'],
        queryStringArray: req.query['query-string-array']?.split(','),
      };

      // Validate request
      const reqValidationErrors =
        validators.validateExhaustiveParamsParams(params);
      if (reqValidationErrors.length) {
        return next(errors.validationErrors(400, reqValidationErrors));
      }

      // Excetute service method
      const service = getService(req);
      await service.exhaustiveParams(params);
      const status = 204;

      // Respond
      res.sendStatus(status);
    } catch (err) {
      next(errors.unhandledException(err));
    }
  };

/** GET /gizmos @deprecated */
export const handleGetGizmos =
  (
    getService: (req: Request) => types.GizmoService,
  ): expressTypes.GetGizmosRequestHandler =>
  async (req, res, next) => {
    try {
      // Parse parameters from request
      const params: types.GetGizmosParams = {
        search: req.query.search,
      };

      // Validate request
      const reqValidationErrors = validators.validateGetGizmosParams(params);
      if (reqValidationErrors.length) {
        return next(errors.validationErrors(400, reqValidationErrors));
      }

      // Excetute service method
      const service = getService(req);
      const result = await service.getGizmos(params);
      const status = 200;

      // Respond
      const reponseDto = mappers.mapToGizmosResponseDto(result);
      res.status(status).json(reponseDto);

      // Validate response
      const resValidationErrors = validators.validateGizmosResponse(result);
      if (resValidationErrors.length) {
        next(errors.validationErrors(500, resValidationErrors));
      }
    } catch (err) {
      next(errors.unhandledException(err));
    }
  };

/** GET /widgets/:id/foo */
export const handleGetWidgetFoo =
  (
    getService: (req: Request) => types.WidgetService,
  ): expressTypes.GetWidgetFooRequestHandler =>
  async (req, res, next) => {
    try {
      // Parse parameters from request
      const params: types.GetWidgetFooParams = {
        id: req.params.id,
      };

      // Validate request
      const reqValidationErrors = validators.validateGetWidgetFooParams(params);
      if (reqValidationErrors.length) {
        return next(errors.validationErrors(400, reqValidationErrors));
      }

      // Excetute service method
      const service = getService(req);
      const result = await service.getWidgetFoo(params);
      const status = 200;

      // Respond
      const reponseDto = mappers.mapToWidgetDto(result);
      res.status(status).json(reponseDto);

      // Validate response
      const resValidationErrors = validators.validateWidget(result);
      if (resValidationErrors.length) {
        next(errors.validationErrors(500, resValidationErrors));
      }
    } catch (err) {
      next(errors.unhandledException(err));
    }
  };

/** GET /widgets */
export const handleGetWidgets =
  (
    getService: (req: Request) => types.WidgetService,
  ): expressTypes.GetWidgetsRequestHandler =>
  async (req, res, next) => {
    try {
      // Excetute service method
      const service = getService(req);
      const result = await service.getWidgets();
      const status = 200;

      // Respond
      const reponseDto = mappers.mapToWidgetDto(result);
      res.status(status).json(reponseDto);

      // Validate response
      const resValidationErrors = validators.validateWidget(result);
      if (resValidationErrors.length) {
        next(errors.validationErrors(500, resValidationErrors));
      }
    } catch (err) {
      next(errors.unhandledException(err));
    }
  };

/** PUT /widgets */
export const handlePutWidget =
  (
    getService: (req: Request) => types.WidgetService,
  ): expressTypes.PutWidgetRequestHandler =>
  async (req, res, next) => {
    try {
      // Excetute service method
      const service = getService(req);
      await service.putWidget();
      const status = 200;

      // Respond
      res.sendStatus(status);
    } catch (err) {
      next(errors.unhandledException(err));
    }
  };

/** PUT /gizmos */
export const handleUpdateGizmo =
  (
    getService: (req: Request) => types.GizmoService,
  ): expressTypes.UpdateGizmoRequestHandler =>
  async (req, res, next) => {
    try {
      // Parse parameters from request
      const params: types.UpdateGizmoParams = {
        factors: req.query.factors?.split(','),
      };

      // Validate request
      const reqValidationErrors = validators.validateUpdateGizmoParams(params);
      if (reqValidationErrors.length) {
        return next(errors.validationErrors(400, reqValidationErrors));
      }

      // Excetute service method
      const service = getService(req);
      const result = await service.updateGizmo(params);
      const status = 200;

      // Respond
      const reponseDto = mappers.mapToGizmoDto(result);
      res.status(status).json(reponseDto);

      // Validate response
      const resValidationErrors = validators.validateGizmo(result);
      if (resValidationErrors.length) {
        next(errors.validationErrors(500, resValidationErrors));
      }
    } catch (err) {
      next(errors.unhandledException(err));
    }
  };

function coerceToBoolean(value: string | boolean): boolean;
function coerceToBoolean(
  value: string | boolean | undefined,
): boolean | undefined;
function coerceToBoolean(
  value: string | boolean | undefined,
): boolean | undefined {
  if (value === undefined) return undefined;

  if (value === 'true') return true;
  if (value === 'false') return false;

  return !!value;
}

function coerceToDate(value: string | Date): Date;
function coerceToDate(value: string | Date | undefined): Date | undefined;
function coerceToDate(value: string | Date | undefined): Date | undefined {
  if (value === undefined) return undefined;

  try {
    const output = new Date(value);
    return isNaN(output.getTime()) ? (value as any) : output;
  } catch {
    return value as any;
  }
}

function coerceToNumber(value: string | number): number;
function coerceToNumber(value: string | number | undefined): number | undefined;
function coerceToNumber(
  value: string | number | undefined,
): number | undefined {
  if (value === undefined) return undefined;

  const output = Number(value);

  return isNaN(output) ? (value as any) : output;
}

const definedBooleans = (value: boolean | undefined): value is boolean =>
  value !== undefined;
const definedNumbers = (value: number | undefined): value is number =>
  value !== undefined;
