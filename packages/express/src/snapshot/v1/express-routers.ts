/**
 * This code was generated by a tool.
 * @basketry/express@{{version}}
 *
 * Changes to this file may cause incorrect behavior and will be lost if
 * the code is regenerated.
 */

function tryParse(obj: any): any {
  try {
    return JSON.parse(obj);
  } catch {
    return;
  }
}

import { Router } from 'express';
import * as types from './types';
import * as validators from './validators';

export function gizmoRoutes(service: types.GizmoService, router?: Router) {
  const r = router || Router();

  // TODO: Auth

  r.route('/gizmos')
    .get(async (req, res, next) => {
      try {
        const params = {
          search: req.query.search as string,
        };

        const errors = validators.validateGetGizmosParams(params);
        if (errors.length) return next(errors);

        // TODO: validate return value
        // TODO: consider response headers
        return res.status(200).json(await service.getGizmos(params));
      } catch (ex) {
        return next(ex);
      }
    })
    .post(async (req, res, next) => {
      try {
        const params = {
          size: req.query.size as types.CreateGizmoSize,
        };

        const errors = validators.validateCreateGizmoParams(params);
        if (errors.length) return next(errors);

        // TODO: validate return value
        // TODO: consider response headers
        return res.status(201).json(await service.createGizmo(params));
      } catch (ex) {
        return next(ex);
      }
    })
    .put(async (req, res, next) => {
      try {
        const params = {
          factors: Array.isArray(req.query.factors)
            ? (req.query.factors as string[])
            : typeof req.query.factors === 'string'
            ? (req.query.factors.split(',') as string[])
            : (req.query.factors as never),
        };

        const errors = validators.validateUpdateGizmoParams(params);
        if (errors.length) return next(errors);

        // TODO: validate return value
        // TODO: consider response headers
        return res.status(200).json(await service.updateGizmo(params));
      } catch (ex) {
        return next(ex);
      }
    })
    .options((req, res) => {
      res.set({ allow: 'GET, POST, PUT, HEAD, OPTIONS' });
      return res.status(204).send();
    })
    .all((req, res) => {
      res.set({ allow: 'GET, POST, PUT, HEAD, OPTIONS' });
      return res.status(405).send();
    });

  return r;
}
export function widgetRoutes(service: types.WidgetService, router?: Router) {
  const r = router || Router();

  // TODO: Auth

  r.route('/widgets')
    .get(async (req, res, next) => {
      try {
        // TODO: validate return value
        // TODO: consider response headers
        return res.status(200).json(await service.getWidgets());
      } catch (ex) {
        return next(ex);
      }
    })
    .post(async (req, res, next) => {
      try {
        const params = {
          body: tryParse(req.body),
        };

        const errors = validators.validateCreateWidgetParams(params);
        if (errors.length) return next(errors);

        // TODO: validate return value
        // TODO: consider response headers
        await service.createWidget(params);
        return res.status(204).send();
      } catch (ex) {
        return next(ex);
      }
    })
    .put(async (req, res, next) => {
      try {
        // TODO: validate return value
        // TODO: consider response headers
        await service.putWidget();
        return res.status(204).send();
      } catch (ex) {
        return next(ex);
      }
    })
    .options((req, res) => {
      res.set({ allow: 'GET, POST, PUT, HEAD, OPTIONS' });
      return res.status(204).send();
    })
    .all((req, res) => {
      res.set({ allow: 'GET, POST, PUT, HEAD, OPTIONS' });
      return res.status(405).send();
    });

  r.route('/widgets/:id/foo')
    .get(async (req, res, next) => {
      try {
        const params = {
          id: req.params.id as string,
        };

        const errors = validators.validateGetWidgetFooParams(params);
        if (errors.length) return next(errors);

        // TODO: validate return value
        // TODO: consider response headers
        return res.status(200).json(await service.getWidgetFoo(params));
      } catch (ex) {
        return next(ex);
      }
    })
    .delete(async (req, res, next) => {
      try {
        const params = {
          id: req.params.id as string,
        };

        const errors = validators.validateDeleteWidgetFooParams(params);
        if (errors.length) return next(errors);

        // TODO: validate return value
        // TODO: consider response headers
        await service.deleteWidgetFoo(params);
        return res.status(204).send();
      } catch (ex) {
        return next(ex);
      }
    })
    .options((req, res) => {
      res.set({ allow: 'GET, DELETE, HEAD, OPTIONS' });
      return res.status(204).send();
    })
    .all((req, res) => {
      res.set({ allow: 'GET, DELETE, HEAD, OPTIONS' });
      return res.status(405).send();
    });

  return r;
}
export function exhaustiveRoutes(
  service: types.ExhaustiveService,
  router?: Router,
) {
  const r = router || Router();

  // TODO: Auth

  r.route(
    '/exhaustive/:path-string/:path-enum/:path-number/:path-integer/:path-boolean/:path-string-array/:path-enum-array/:path-number-array/:path-integer-array/:path-boolean-array',
  )
    .get(async (req, res, next) => {
      try {
        const params = {
          queryString: req.query['query-string'] as string,
          queryEnum: req.query['query-enum'] as types.ExhaustiveParamsQueryEnum,
          queryNumber: Number(`${req.query['query-number']}`),
          queryInteger: Number(`${req.query['query-integer']}`),
          queryBoolean:
            typeof req.query['query-boolean'] !== 'undefined' &&
            `${req.query['query-boolean']}`.toLowerCase() !== 'false',
          queryStringArray: Array.isArray(req.query['query-string-array'])
            ? (req.query['query-string-array'] as string[])
            : typeof req.query['query-string-array'] === 'string'
            ? (req.query['query-string-array'].split(',') as string[])
            : (req.query['query-string-array'] as never),
          queryEnumArray: Array.isArray(req.query['query-enum-array'])
            ? (req.query[
                'query-enum-array'
              ] as types.ExhaustiveParamsQueryEnumArray[])
            : typeof req.query['query-enum-array'] === 'string'
            ? (req.query['query-enum-array'].split(
                ',',
              ) as types.ExhaustiveParamsQueryEnumArray[])
            : (req.query['query-enum-array'] as never),
          queryNumberArray: Array.isArray(req.query['query-number-array'])
            ? req.query['query-number-array'].map((x: any) => Number(`${x}`))
            : typeof req.query['query-number-array'] === 'string'
            ? req.query['query-number-array']
                .split(',')
                .map((x: any) => Number(`${x}`))
            : (req.query['query-number-array'] as never),
          queryIntegerArray: Array.isArray(req.query['query-integer-array'])
            ? req.query['query-integer-array'].map((x: any) => Number(`${x}`))
            : typeof req.query['query-integer-array'] === 'string'
            ? req.query['query-integer-array']
                .split(',')
                .map((x: any) => Number(`${x}`))
            : (req.query['query-integer-array'] as never),
          queryBooleanArray: Array.isArray(req.query['query-boolean-array'])
            ? req.query['query-boolean-array'].map(
                (x: any) =>
                  typeof x !== 'undefined' && `${x}`.toLowerCase() !== 'false',
              )
            : typeof req.query['query-boolean-array'] === 'string'
            ? req.query['query-boolean-array']
                .split(',')
                .map(
                  (x: any) =>
                    typeof x !== 'undefined' &&
                    `${x}`.toLowerCase() !== 'false',
                )
            : (req.query['query-boolean-array'] as never),
          pathString: req.params['path-string'] as string,
          pathEnum: req.params['path-enum'] as types.ExhaustiveParamsPathEnum,
          pathNumber: Number(`${req.params['path-number']}`),
          pathInteger: Number(`${req.params['path-integer']}`),
          pathBoolean:
            typeof req.params['path-boolean'] !== 'undefined' &&
            `${req.params['path-boolean']}`.toLowerCase() !== 'false',
          pathStringArray: Array.isArray(req.params['path-string-array'])
            ? (req.params['path-string-array'] as string[])
            : typeof req.params['path-string-array'] === 'string'
            ? (req.params['path-string-array'].split(',') as string[])
            : (req.params['path-string-array'] as never),
          pathEnumArray: Array.isArray(req.params['path-enum-array'])
            ? (req.params[
                'path-enum-array'
              ] as types.ExhaustiveParamsPathEnumArray[])
            : typeof req.params['path-enum-array'] === 'string'
            ? (req.params['path-enum-array'].split(
                ',',
              ) as types.ExhaustiveParamsPathEnumArray[])
            : (req.params['path-enum-array'] as never),
          pathNumberArray: Array.isArray(req.params['path-number-array'])
            ? req.params['path-number-array'].map((x: any) => Number(`${x}`))
            : typeof req.params['path-number-array'] === 'string'
            ? req.params['path-number-array']
                .split(',')
                .map((x: any) => Number(`${x}`))
            : (req.params['path-number-array'] as never),
          pathIntegerArray: Array.isArray(req.params['path-integer-array'])
            ? req.params['path-integer-array'].map((x: any) => Number(`${x}`))
            : typeof req.params['path-integer-array'] === 'string'
            ? req.params['path-integer-array']
                .split(',')
                .map((x: any) => Number(`${x}`))
            : (req.params['path-integer-array'] as never),
          pathBooleanArray: Array.isArray(req.params['path-boolean-array'])
            ? req.params['path-boolean-array'].map(
                (x: any) =>
                  typeof x !== 'undefined' && `${x}`.toLowerCase() !== 'false',
              )
            : typeof req.params['path-boolean-array'] === 'string'
            ? req.params['path-boolean-array']
                .split(',')
                .map(
                  (x: any) =>
                    typeof x !== 'undefined' &&
                    `${x}`.toLowerCase() !== 'false',
                )
            : (req.params['path-boolean-array'] as never),
          headerString: req.header('header-string') as any as string,
          headerEnum: req.header(
            'header-enum',
          ) as any as types.ExhaustiveParamsHeaderEnum,
          headerNumber: Number(`${req.header('header-number') as any}`),
          headerInteger: Number(`${req.header('header-integer') as any}`),
          headerBoolean:
            typeof (req.header('header-boolean') as any) !== 'undefined' &&
            `${req.header('header-boolean') as any}`.toLowerCase() !== 'false',
          headerStringArray: Array.isArray(
            req.header('header-string-array') as any,
          )
            ? (req.header('header-string-array') as any as string[])
            : typeof (req.header('header-string-array') as any) === 'string'
            ? ((req.header('header-string-array') as any).split(
                ',',
              ) as string[])
            : (req.header('header-string-array') as any as never),
          headerEnumArray: Array.isArray(req.header('header-enum-array') as any)
            ? (req.header(
                'header-enum-array',
              ) as any as types.ExhaustiveParamsHeaderEnumArray[])
            : typeof (req.header('header-enum-array') as any) === 'string'
            ? ((req.header('header-enum-array') as any).split(
                ',',
              ) as types.ExhaustiveParamsHeaderEnumArray[])
            : (req.header('header-enum-array') as any as never),
          headerNumberArray: Array.isArray(
            req.header('header-number-array') as any,
          )
            ? (req.header('header-number-array') as any).map((x: any) =>
                Number(`${x}`),
              )
            : typeof (req.header('header-number-array') as any) === 'string'
            ? (req.header('header-number-array') as any)
                .split(',')
                .map((x: any) => Number(`${x}`))
            : (req.header('header-number-array') as any as never),
          headerIntegerArray: Array.isArray(
            req.header('header-integer-array') as any,
          )
            ? (req.header('header-integer-array') as any).map((x: any) =>
                Number(`${x}`),
              )
            : typeof (req.header('header-integer-array') as any) === 'string'
            ? (req.header('header-integer-array') as any)
                .split(',')
                .map((x: any) => Number(`${x}`))
            : (req.header('header-integer-array') as any as never),
          headerBooleanArray: Array.isArray(
            req.header('header-boolean-array') as any,
          )
            ? (req.header('header-boolean-array') as any).map(
                (x: any) =>
                  typeof x !== 'undefined' && `${x}`.toLowerCase() !== 'false',
              )
            : typeof (req.header('header-boolean-array') as any) === 'string'
            ? (req.header('header-boolean-array') as any)
                .split(',')
                .map(
                  (x: any) =>
                    typeof x !== 'undefined' &&
                    `${x}`.toLowerCase() !== 'false',
                )
            : (req.header('header-boolean-array') as any as never),
          body: tryParse(req.body),
        };

        const errors = validators.validateExhaustiveParamsParams(params);
        if (errors.length) return next(errors);

        // TODO: validate return value
        // TODO: consider response headers
        await service.exhaustiveParams(params);
        return res.status(204).send();
      } catch (ex) {
        return next(ex);
      }
    })
    .options((req, res) => {
      res.set({ allow: 'GET, HEAD, OPTIONS' });
      return res.status(204).send();
    })
    .all((req, res) => {
      res.set({ allow: 'GET, HEAD, OPTIONS' });
      return res.status(405).send();
    });

  return r;
}
